## API Report File for "@backstage/plugin-catalog-backend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { CatalogApi } from '@backstage/catalog-client';
import { CatalogEntityDocument as CatalogEntityDocument_2 } from '@backstage/plugin-catalog-common';
import { CompoundEntityRef } from '@backstage/catalog-model';
import { ConditionalPolicyDecision } from '@backstage/plugin-permission-node';
import { Conditions } from '@backstage/plugin-permission-node';
import { Config } from '@backstage/config';
import { DocumentCollatorFactory } from '@backstage/plugin-search-common';
import { Entity } from '@backstage/catalog-model';
import { EntityPolicy } from '@backstage/catalog-model';
import express from 'express';
import { GetEntitiesRequest } from '@backstage/catalog-client';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { Location as Location_2 } from '@backstage/catalog-client';
import { Logger } from 'winston';
import { Permission } from '@backstage/plugin-permission-common';
import { PermissionAuthorizer } from '@backstage/plugin-permission-common';
import { PermissionCondition } from '@backstage/plugin-permission-common';
import { PermissionCriteria } from '@backstage/plugin-permission-common';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { Readable } from 'stream';
import { Router } from 'express';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { TokenManager } from '@backstage/backend-common';
import { UrlReader } from '@backstage/backend-common';
import { Validators } from '@backstage/catalog-model';

// @public (undocumented)
export type AnalyzeLocationEntityField = {
  field: string;
  state:
    | 'analysisSuggestedValue'
    | 'analysisSuggestedNoValue'
    | 'needsUserInput';
  value: string | null;
  description: string;
};

// @public
export type AnalyzeLocationExistingEntity = {
  location: LocationSpec;
  isRegistered: boolean;
  entity: Entity;
};

// @public
export type AnalyzeLocationGenerateEntity = {
  entity: RecursivePartial<Entity>;
  fields: AnalyzeLocationEntityField[];
};

// @public (undocumented)
export type AnalyzeLocationRequest = {
  location: LocationSpec;
};

// @public (undocumented)
export type AnalyzeLocationResponse = {
  existingEntityFiles: AnalyzeLocationExistingEntity[];
  generateEntities: AnalyzeLocationGenerateEntity[];
};

// @public (undocumented)
export class AnnotateLocationEntityProcessor implements CatalogProcessor {
  constructor(options: { integrations: ScmIntegrationRegistry });
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  preProcessEntity(
    entity: Entity,
    location: LocationSpec,
    _: CatalogProcessorEmit,
    originLocation: LocationSpec,
  ): Promise<Entity>;
}

// @public (undocumented)
export class AnnotateScmSlugEntityProcessor implements CatalogProcessor {
  constructor(opts: { scmIntegrationRegistry: ScmIntegrationRegistry });
  // (undocumented)
  static fromConfig(config: Config): AnnotateScmSlugEntityProcessor;
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

// @public (undocumented)
export class BuiltinKindsEntityProcessor implements CatalogProcessor {
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  postProcessEntity(
    entity: Entity,
    _location: LocationSpec,
    emit: CatalogProcessorEmit,
  ): Promise<Entity>;
  // (undocumented)
  validateEntityKind(entity: Entity): Promise<boolean>;
}

// @public
export class CatalogBuilder {
  addEntityPolicy(...policies: EntityPolicy[]): CatalogBuilder;
  addEntityProvider(...providers: EntityProvider[]): CatalogBuilder;
  addPermissionRules(
    ...permissionRules: PermissionRule<
      Entity,
      EntitiesSearchFilter,
      unknown[]
    >[]
  ): void;
  addProcessor(...processors: CatalogProcessor[]): CatalogBuilder;
  build(): Promise<{
    entitiesCatalog: EntitiesCatalog;
    locationAnalyzer: LocationAnalyzer;
    processingEngine: CatalogProcessingEngine;
    locationService: LocationService;
    router: Router;
  }>;
  static create(env: CatalogEnvironment): CatalogBuilder;
  getDefaultProcessors(): CatalogProcessor[];
  replaceEntityPolicies(policies: EntityPolicy[]): CatalogBuilder;
  replaceProcessors(processors: CatalogProcessor[]): CatalogBuilder;
  setEntityDataParser(parser: CatalogProcessorParser): CatalogBuilder;
  setFieldFormatValidators(validators: Partial<Validators>): CatalogBuilder;
  setLocationAnalyzer(locationAnalyzer: LocationAnalyzer): CatalogBuilder;
  setPlaceholderResolver(
    key: string,
    resolver: PlaceholderResolver,
  ): CatalogBuilder;
  setProcessingInterval(
    processingInterval: ProcessingIntervalFunction,
  ): CatalogBuilder;
  setProcessingIntervalSeconds(seconds: number): CatalogBuilder;
  // @deprecated
  setRefreshInterval(refreshInterval: RefreshIntervalFunction): CatalogBuilder;
  // @deprecated
  setRefreshIntervalSeconds(seconds: number): CatalogBuilder;
}

// @alpha
export const catalogConditions: Conditions<{
  hasAnnotation: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [annotation: string]
  >;
  hasLabel: PermissionRule<Entity, EntitiesSearchFilter, [label: string]>;
  hasMetadata: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [key: string, value?: string | undefined]
  >;
  hasSpec: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [key: string, value?: string | undefined]
  >;
  isEntityKind: PermissionRule<Entity, EntitiesSearchFilter, [kinds: string[]]>;
  isEntityOwner: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [claims: string[]]
  >;
}>;

// @public @deprecated (undocumented)
export type CatalogEntityDocument = CatalogEntityDocument_2;

// @public (undocumented)
export type CatalogEnvironment = {
  logger: Logger;
  database: PluginDatabaseManager;
  config: Config;
  reader: UrlReader;
  permissions: PermissionAuthorizer;
};

// @public (undocumented)
export interface CatalogProcessingEngine {
  // (undocumented)
  start(): Promise<void>;
  // (undocumented)
  stop(): Promise<void>;
}

// @public
export interface CatalogProcessingOrchestrator {
  // (undocumented)
  process(request: EntityProcessingRequest): Promise<EntityProcessingResult>;
}

// @public (undocumented)
export type CatalogProcessor = {
  getProcessorName(): string;
  readLocation?(
    location: LocationSpec,
    optional: boolean,
    emit: CatalogProcessorEmit,
    parser: CatalogProcessorParser,
    cache: CatalogProcessorCache,
  ): Promise<boolean>;
  preProcessEntity?(
    entity: Entity,
    location: LocationSpec,
    emit: CatalogProcessorEmit,
    originLocation: LocationSpec,
    cache: CatalogProcessorCache,
  ): Promise<Entity>;
  validateEntityKind?(entity: Entity): Promise<boolean>;
  postProcessEntity?(
    entity: Entity,
    location: LocationSpec,
    emit: CatalogProcessorEmit,
    cache: CatalogProcessorCache,
  ): Promise<Entity>;
};

// @public
export interface CatalogProcessorCache {
  get<ItemType extends JsonValue>(key: string): Promise<ItemType | undefined>;
  set<ItemType extends JsonValue>(key: string, value: ItemType): Promise<void>;
}

// @public (undocumented)
export type CatalogProcessorEmit = (generated: CatalogProcessorResult) => void;

// @public (undocumented)
export type CatalogProcessorEntityResult = {
  type: 'entity';
  entity: Entity;
  location: LocationSpec;
};

// @public (undocumented)
export type CatalogProcessorErrorResult = {
  type: 'error';
  error: Error;
  location: LocationSpec;
};

// @public (undocumented)
export type CatalogProcessorLocationResult = {
  type: 'location';
  location: LocationSpec;
};

// @public
export type CatalogProcessorParser = (options: {
  data: Buffer;
  location: LocationSpec;
}) => AsyncIterable<CatalogProcessorResult>;

// @public (undocumented)
export type CatalogProcessorRelationResult = {
  type: 'relation';
  relation: EntityRelationSpec;
};

// @public (undocumented)
export type CatalogProcessorResult =
  | CatalogProcessorLocationResult
  | CatalogProcessorEntityResult
  | CatalogProcessorRelationResult
  | CatalogProcessorErrorResult;

// @public
export type CatalogRule = {
  allow: Array<{
    kind: string;
  }>;
  locations?: Array<{
    target?: string;
    type: string;
  }>;
};

// @public
export type CatalogRulesEnforcer = {
  isAllowed(entity: Entity, location: LocationSpec): boolean;
};

// @public (undocumented)
export class CodeOwnersProcessor implements CatalogProcessor {
  constructor(options: {
    integrations: ScmIntegrationRegistry;
    logger: Logger;
    reader: UrlReader;
  });
  // (undocumented)
  static fromConfig(
    config: Config,
    options: {
      logger: Logger;
      reader: UrlReader;
    },
  ): CodeOwnersProcessor;
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

// @alpha
export const createCatalogPermissionRule: <TParams extends unknown[]>(
  rule: PermissionRule<Entity, EntitiesSearchFilter, TParams>,
) => PermissionRule<Entity, EntitiesSearchFilter, TParams>;

// @alpha
export const createCatalogPolicyDecision: (
  conditions: PermissionCriteria<PermissionCondition<unknown[]>>,
) => ConditionalPolicyDecision;

// @public
export function createRandomProcessingInterval(options: {
  minSeconds: number;
  maxSeconds: number;
}): ProcessingIntervalFunction;

// @public @deprecated
export function createRandomRefreshInterval(options: {
  minSeconds: number;
  maxSeconds: number;
}): RefreshIntervalFunction;

// @public
export function createRouter(options: RouterOptions): Promise<express.Router>;

// @public @deprecated (undocumented)
export class DefaultCatalogCollator {
  constructor(options: {
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    locationTemplate?: string;
    filter?: GetEntitiesRequest['filter'];
    catalogClient?: CatalogApi;
  });
  // (undocumented)
  protected applyArgsToFormat(
    format: string,
    args: Record<string, string>,
  ): string;
  // (undocumented)
  protected readonly catalogClient: CatalogApi;
  // (undocumented)
  protected discovery: PluginEndpointDiscovery;
  // (undocumented)
  execute(): Promise<CatalogEntityDocument_2[]>;
  // (undocumented)
  protected filter?: GetEntitiesRequest['filter'];
  // (undocumented)
  static fromConfig(
    _config: Config,
    options: {
      discovery: PluginEndpointDiscovery;
      tokenManager: TokenManager;
      filter?: GetEntitiesRequest['filter'];
    },
  ): DefaultCatalogCollator;
  // (undocumented)
  protected locationTemplate: string;
  // (undocumented)
  protected tokenManager: TokenManager;
  // (undocumented)
  readonly type: string;
  // (undocumented)
  readonly visibilityPermission: Permission;
}

// @public (undocumented)
export class DefaultCatalogCollatorFactory implements DocumentCollatorFactory {
  // (undocumented)
  static fromConfig(
    _config: Config,
    options: DefaultCatalogCollatorFactoryOptions,
  ): DefaultCatalogCollatorFactory;
  // (undocumented)
  getCollator(): Promise<Readable>;
  // (undocumented)
  readonly type: string;
  // (undocumented)
  readonly visibilityPermission: Permission;
}

// @public (undocumented)
export type DefaultCatalogCollatorFactoryOptions = {
  discovery: PluginEndpointDiscovery;
  tokenManager: TokenManager;
  locationTemplate?: string;
  filter?: GetEntitiesRequest['filter'];
  batchSize?: number;
  catalogClient?: CatalogApi;
};

// @public (undocumented)
export class DefaultCatalogProcessingOrchestrator
  implements CatalogProcessingOrchestrator
{
  constructor(options: {
    processors: CatalogProcessor[];
    integrations: ScmIntegrationRegistry;
    logger: Logger;
    parser: CatalogProcessorParser;
    policy: EntityPolicy;
    rulesEnforcer: CatalogRulesEnforcer;
  });
  // (undocumented)
  process(request: EntityProcessingRequest): Promise<EntityProcessingResult>;
}

// @public
export class DefaultCatalogRulesEnforcer implements CatalogRulesEnforcer {
  constructor(rules: CatalogRule[]);
  static readonly defaultRules: CatalogRule[];
  static fromConfig(config: Config): DefaultCatalogRulesEnforcer;
  isAllowed(entity: Entity, location: LocationSpec): boolean;
}

// @public
export type DeferredEntity = {
  entity: Entity;
  locationKey?: string;
};

// @public (undocumented)
export type EntitiesCatalog = {
  entities(request?: EntitiesRequest): Promise<EntitiesResponse>;
  removeEntityByUid(
    uid: string,
    options?: {
      authorizationToken?: string;
    },
  ): Promise<void>;
  entityAncestry(
    entityRef: string,
    options?: {
      authorizationToken?: string;
    },
  ): Promise<EntityAncestryResponse>;
  facets(request: EntityFacetsRequest): Promise<EntityFacetsResponse>;
};

// @public (undocumented)
export type EntitiesRequest = {
  filter?: EntityFilter;
  fields?: (entity: Entity) => Entity;
  pagination?: EntityPagination;
  authorizationToken?: string;
};

// @public (undocumented)
export type EntitiesResponse = {
  entities: Entity[];
  pageInfo: PageInfo;
};

// @public
export type EntitiesSearchFilter = {
  key: string;
  values?: string[];
};

// @public @deprecated (undocumented)
function entity(
  atLocation: LocationSpec,
  newEntity: Entity,
): CatalogProcessorResult;

// @public (undocumented)
export type EntityAncestryResponse = {
  rootEntityRef: string;
  items: Array<{
    entity: Entity;
    parentEntityRefs: string[];
  }>;
};

// @public
export interface EntityFacetsRequest {
  authorizationToken?: string;
  facets: string[];
  filter?: EntityFilter;
}

// @public
export interface EntityFacetsResponse {
  facets: Record<
    string,
    Array<{
      value: string;
      count: number;
    }>
  >;
}

// @public
export type EntityFilter =
  | {
      allOf: EntityFilter[];
    }
  | {
      anyOf: EntityFilter[];
    }
  | {
      not: EntityFilter;
    }
  | EntitiesSearchFilter;

// @public
export type EntityPagination = {
  limit?: number;
  offset?: number;
  after?: string;
};

// @public
export type EntityProcessingRequest = {
  entity: Entity;
  state?: JsonObject;
};

// @public
export type EntityProcessingResult =
  | {
      ok: true;
      state: JsonObject;
      completedEntity: Entity;
      deferredEntities: DeferredEntity[];
      relations: EntityRelationSpec[];
      errors: Error[];
    }
  | {
      ok: false;
      errors: Error[];
    };

// @public
export interface EntityProvider {
  connect(connection: EntityProviderConnection): Promise<void>;
  getProviderName(): string;
}

// @public
export interface EntityProviderConnection {
  applyMutation(mutation: EntityProviderMutation): Promise<void>;
}

// @public
export type EntityProviderMutation =
  | {
      type: 'full';
      entities: DeferredEntity[];
    }
  | {
      type: 'delta';
      added: DeferredEntity[];
      removed: DeferredEntity[];
    };

// @public
export type EntityRelationSpec = {
  source: CompoundEntityRef;
  type: string;
  target: CompoundEntityRef;
};

// @public (undocumented)
export class FileReaderProcessor implements CatalogProcessor {
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  readLocation(
    location: LocationSpec,
    optional: boolean,
    emit: CatalogProcessorEmit,
    parser: CatalogProcessorParser,
  ): Promise<boolean>;
}

// @public @deprecated (undocumented)
function generalError(
  atLocation: LocationSpec,
  message: string,
): CatalogProcessorResult;

// @public @deprecated (undocumented)
function inputError(
  atLocation: LocationSpec,
  message: string,
): CatalogProcessorResult;

// @public @deprecated (undocumented)
function location_2(
  newLocation: LocationSpec,
  _optional?: boolean,
): CatalogProcessorResult;

// @public (undocumented)
export type LocationAnalyzer = {
  analyzeLocation(
    location: AnalyzeLocationRequest,
  ): Promise<AnalyzeLocationResponse>;
};

// @public (undocumented)
export class LocationEntityProcessor implements CatalogProcessor {
  constructor(options: LocationEntityProcessorOptions);
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  postProcessEntity(
    entity: Entity,
    location: LocationSpec,
    emit: CatalogProcessorEmit,
  ): Promise<Entity>;
}

// @public (undocumented)
export type LocationEntityProcessorOptions = {
  integrations: ScmIntegrationRegistry;
};

// @public
export interface LocationInput {
  // @deprecated (undocumented)
  presence?: 'optional' | 'required';
  // (undocumented)
  target: string;
  // (undocumented)
  type: string;
}

// @public
export interface LocationService {
  // (undocumented)
  createLocation(
    location: LocationInput,
    dryRun: boolean,
    options?: {
      authorizationToken?: string;
    },
  ): Promise<{
    location: Location_2;
    entities: Entity[];
    exists?: boolean;
  }>;
  // (undocumented)
  deleteLocation(
    id: string,
    options?: {
      authorizationToken?: string;
    },
  ): Promise<void>;
  // (undocumented)
  getLocation(
    id: string,
    options?: {
      authorizationToken?: string;
    },
  ): Promise<Location_2>;
  // (undocumented)
  listLocations(options?: {
    authorizationToken?: string;
  }): Promise<Location_2[]>;
}

// @public
export type LocationSpec = {
  type: string;
  target: string;
  presence?: 'optional' | 'required';
};

// @public
export interface LocationStore {
  // (undocumented)
  createLocation(location: LocationInput): Promise<Location_2>;
  // (undocumented)
  deleteLocation(id: string): Promise<void>;
  // (undocumented)
  getLocation(id: string): Promise<Location_2>;
  // (undocumented)
  listLocations(): Promise<Location_2[]>;
}

// @public @deprecated (undocumented)
function notFoundError(
  atLocation: LocationSpec,
  message: string,
): CatalogProcessorResult;

// @public (undocumented)
export type PageInfo =
  | {
      hasNextPage: false;
    }
  | {
      hasNextPage: true;
      endCursor: string;
    };

// @public (undocumented)
export function parseEntityYaml(
  data: Buffer,
  location: LocationSpec,
): Iterable<CatalogProcessorResult>;

// @alpha
export const permissionRules: {
  hasAnnotation: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [annotation: string]
  >;
  hasLabel: PermissionRule<Entity, EntitiesSearchFilter, [label: string]>;
  hasMetadata: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [key: string, value?: string | undefined]
  >;
  hasSpec: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [key: string, value?: string | undefined]
  >;
  isEntityKind: PermissionRule<Entity, EntitiesSearchFilter, [kinds: string[]]>;
  isEntityOwner: PermissionRule<
    Entity,
    EntitiesSearchFilter,
    [claims: string[]]
  >;
};

// @public
export class PlaceholderProcessor implements CatalogProcessor {
  constructor(options: PlaceholderProcessorOptions);
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

// @public (undocumented)
export type PlaceholderProcessorOptions = {
  resolvers: Record<string, PlaceholderResolver>;
  reader: UrlReader;
  integrations: ScmIntegrationRegistry;
};

// @public (undocumented)
export type PlaceholderResolver = (
  params: PlaceholderResolverParams,
) => Promise<JsonValue>;

// @public (undocumented)
export type PlaceholderResolverParams = {
  key: string;
  value: JsonValue;
  baseUrl: string;
  read: PlaceholderResolverRead;
  resolveUrl: PlaceholderResolverResolveUrl;
};

// @public (undocumented)
export type PlaceholderResolverRead = (url: string) => Promise<Buffer>;

// @public (undocumented)
export type PlaceholderResolverResolveUrl = (
  url: string,
  base: string,
) => string;

// @public
export type ProcessingIntervalFunction = () => number;

// @public
export const processingResult: Readonly<{
  readonly notFoundError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly inputError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly generalError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly location: (newLocation: LocationSpec) => CatalogProcessorResult;
  readonly entity: (
    atLocation: LocationSpec,
    newEntity: Entity,
  ) => CatalogProcessorResult;
  readonly relation: (spec: EntityRelationSpec) => CatalogProcessorResult;
}>;

// @public
export type RecursivePartial<T> = {
  [P in keyof T]?: T[P] extends (infer U)[]
    ? RecursivePartial<U>[]
    : T[P] extends object
    ? RecursivePartial<T[P]>
    : T[P];
};

// @public @deprecated
export type RefreshIntervalFunction = () => number;

// @public
export type RefreshOptions = {
  entityRef: string;
  authorizationToken?: string;
};

// @public
export interface RefreshService {
  refresh(options: RefreshOptions): Promise<void>;
}

// @public @deprecated (undocumented)
function relation(spec: EntityRelationSpec): CatalogProcessorResult;

declare namespace results {
  export {
    notFoundError,
    inputError,
    generalError,
    location_2 as location,
    entity,
    relation,
  };
}
export { results };

// @public
export interface RouterOptions {
  // (undocumented)
  config: Config;
  // (undocumented)
  entitiesCatalog?: EntitiesCatalog;
  // (undocumented)
  locationAnalyzer?: LocationAnalyzer;
  // (undocumented)
  locationService: LocationService;
  // (undocumented)
  logger: Logger;
  // (undocumented)
  permissionIntegrationRouter?: express.Router;
  // (undocumented)
  refreshService?: RefreshService;
}

// @public (undocumented)
export class UrlReaderProcessor implements CatalogProcessor {
  constructor(options: { reader: UrlReader; logger: Logger });
  // (undocumented)
  getProcessorName(): string;
  // (undocumented)
  readLocation(
    location: LocationSpec,
    optional: boolean,
    emit: CatalogProcessorEmit,
    parser: CatalogProcessorParser,
    cache: CatalogProcessorCache,
  ): Promise<boolean>;
}
```
